# learn
#完全背包问题

和之前不太一样的是，在完全背包问题中，物体是可以无限次使用的。

分析状态动作：在背包重量为V的情况下，背包可以达到的最大价值为？？？  动作，任然是每一次是否会装物体，对于第I个物体来说，如果其重量没有超的话，则
可以选择装或者不装，装的时候可以装的次数为：
    当前的背包的容量j,剩余容量为V-j ,可以装的物体I的次数为(V-j)//c_i
    ## 思路1：
    假设这个变量为k，K的个数是不定的，如果是按照我们之前0-1背包问题来讲的话，其该问题可以写成如下形式：
    
 
    dp[i][v] = max( dp[i-1][v-k*c[i] + k * w[i] for all k )
             = max (dp[i-1][v], max( dp[i-1][v-k*c[i]]+k*w[i] for 1<=k)
             = max (dp[i-1][v], max (dp[i-1][v- c[i] - k*c[i]] + k *w[i] for 0<=k ) + w[i] )
             = max (dp[i-1][v], dp[i][v-c[i]] + w[i] )
         
    （我之前一直没有理解这个地方，主要是没有将最开始的等式进行转换，导致写代码的时候很麻烦，还加了一个关于k的循环。因此没有得到下面的等式，在
    做的时候要注意进行等式的转换）。
    
    从这里我们可以看到完全背包问题和0-1问题的动态转移方程上面是相似的，在0-1问题中：
   
           dp[i][v]=max(dp[i-1][v],dp[i-1][v-c[i] + w[i])
        
    可以发现只有后面的dp[i-1][v-c[i]]不太相同，在完全背包问题中还和现在重量下i件物体的背包存在关系
    
    按照这个思路将具体的代码写在之后的complete_package1中。

  ## 思路2：
  
但是我们可以发现，在上面的过程中，我们在求解dp[i][v]的时候时间复杂度为O(V/c_i),总的时间复杂度为O(V*sum(V/c_i)),所以复杂度还是比较的高。这个时候
我们可以考虑一下基本的情况0-1背包问题，需要将完全背包问题转换成0-1背包问题。在0-1背包问题中每一个物体只允许放入一次，现在对于每个商品可以放入
很多次，现在我们可以将每个物体划分成合适份额的小物体，此时可以看作每个小物体只能放入一次，这样就转变成为了0-1背包经典问题。

    对于第i个物体来说，其重量为c_i，对于该物体来说可以划分的份额为V/c_i次，这样的话，划分之后的每个小物体的重量为：c[i]//k，但是有的时候我们的
物体可能并不能分成K分，此时V/C_i等于0，因此为了避免这种情况，我们采用二进制的写法，当件数写成二进制的情况（？？？？）便于好计算，对于该物体分成
若干个重量为c_i*2^k,价值为w_i*2^k的物品，2^k表示放的件数2^K选自c_i * 2^k <= V

   具体的内容详见代码complete_package2
   
  ##思路3： 
  
   上面这是一种思路，但是不知道为什么我在实现出来的结果不是很对，因此，后面再要学习，下面继续第三种想法，我们在进行放物品的时候，当然要选择
   代价小且价值大的物体存放到包中。即对于两个物体i,j来说
   ```
     若 c[i]>c[j] and w[i]<w[j]的话，则用物体j代替物体i，这样的做法也是将物体进行了多次放入
   ```   
   具体详见complete_package3   

    
    
